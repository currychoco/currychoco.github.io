---
layout: post
title: 객체지향 설계와 스프링
categories: [스프링 핵심 원리 기본편]
comments: true
---

##### 스프링 역사
1. EJB : 이론은 엄청 좋지만 실사용에 무리가 있고, 느리고, 비싸서 매우 불편했음
2. 이에 불만을 지닌 이들 중 한 명인 '로드 존슨'이 2002년에 책을 출간함 -> EJB없이도 고품질의 확장 가능한 애플리케이션을 개발할 수 있었음
3. 책 출간 이후 유겐 휠러, 얀 카로프가 로드 존슨에게 오픈소스 프로젝트를 제안


##### 스프링 프레임워크
* 핵심 기술 : 스프링 DI 컨테이너, AOP, 이벤트, 기타
* 웹 기술 : 스프링 MVC, 스프링 WebFlux
* 데이터 접근 기술 : 트랜잭션, JDBC, ORM 지원, XML 지원
* 기술 통합 : 캐시, 이메일, 원격접근, 스케줄링
* 테스트 : 스프링 기반 테스트 지원
* 언어 : 코틀린, 그루비


##### 스프링 부트
* 스프링을 편리하게 사용할 수 있도록 지원
* Tomcat같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨
* 모니터링 기능 지원(actuator)


##### 스프링이란 
* 스프링이라는 단어는 문맥에 따라 다르게 사용됨
  * 스프링 DI 컨테이너 기술이 제일 중요함
  * 스프링 부트, 스프링 프레임 워크, 스프링 데이터 등을 모두 포함한 것이 스프링 생태계임


##### 스프링 핵심
* 스프링은 자바 언어 기반의 프레임 워크 -> 자바 언어의 가장 큰 특징은 객채 지향 언어임
* 이러한 객체 지향 언어의 특징을 가장 잘 살릴 수 있는 것이 스프링 프레임워크임 -> 스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와줌


-------

##### 객체 지향 특징
* 추상화
* 캡슐화
* 상속
* 다형성 -> 제일 중요함, 객체 지향의 꽃


##### 객체 지향 프로그래밍
* 여러 개의 독립된 객체들의 모임. 객체들은 서로 메시지를 주고받고 데이터를 처리할 수 있음
* -> 객체 지향 프로그래밍은 프로그램을 유연하고 변경이 용이하게 만듦
  * 유연, 변경 용이 : 컴퓨터 부품 갈아 끼우듯이, 레고 블럭 조립하듯이 컴포넌트를 쉽고 유연하게 변경하면서 개발할 수 있는 방법

-------

##### 다형성
* 역할과 구현으로 세상을 구분
![image](https://user-images.githubusercontent.com/107798750/208855400-9d6e564b-9841-4d41-b3c0-b37e359a45ea.png)
* 운전자는 자동차가 자동차의 역할을 하기만 하면 운전할 수 있음
* 운전자는 자동차의 내부 구조를 몰라도 운전할 수 있음
* 운전자는 자동차 내부 구조가 바뀌어도 운전할 수 있음
* 운전자는 아반떼에서 SVU로 바뀌어도 운전할 수 있음
![image](https://user-images.githubusercontent.com/107798750/208856702-70a9c711-52d1-4e80-ac5d-84f4ec488f3f.png)
* 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경 가능
* 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경 가능


-------

##### 좋은 객체 지향 설계의 5가지 원칙

######SOLID
* SRP(Single Responsibiliby Principle) : 단일 책임 원칙
  * 한 클래스는 하나의 책임만 가져야 함. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것임
* OCP(Open/Closed Principle) : 개방-폐쇄 원칙
  * 확장에는 열려 있으나, 수정, 변경에는 닫혀있어야 함. 다형성을 생각해 보면 됨 -> 인터페이스를 구현한 새로운 클래스를 만들어서 새로운 기능 구현 -> 확장!
  * 그러나 순수 자바에서는 다형성을 사용하도 해당 원칙을 지킬 수 없음
![image](https://user-images.githubusercontent.com/107798750/208857786-3bf6822e-8234-447b-931e-27882254b891.png)
  * 그러므로 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요함 -> 이게 스프링
* LSP(Liskov Substitution pPrinciple) : 리스코프 치환 원칙
  * 인터페이스로 규정된 것을 구현할 때 위반해서는 안 됨. ex) 엑셀을 밟았을 때 앞으로 나아가기로 인터페이스에 규정해 놨는데, 구현할 때 엑셀을 밟으면 멈추게 하는 것은 리브코프 치환 원칙 위배
* ISP(Interface Segregation Principle) : 인터페이스 분리 원칙
  * 여러 기능을 지닌 인터페이스 하나 보다 특정 기능들로 작게 쪼갠 인터페이스 여러 개가 나음
  * 인터페이스가 명확해지고, 대체 가능성이 높아짐
  * ex) 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리 
* DIP(Dependency Inversion Principle) : 의존관계 역전 원칙
  * 추상화에 의존해야지, 구체화에 의존하면 안 됨
  * 구현 클래스에 의존하지 말고 인터페이스에 의존하라는 뜻
  * 인터페이스에 의존해야 유연하게 구현체를 바꿀 수 있음 
  * 한계 : DIP 는 자바의 다형성만으로는 원칙을 지킬 수 없음. 선언할 때는 인터페이스를 선언하더라도, 자료형으로 구현클래스를 사용하기 때문


##### SOLID 한계와 스프링의 지원
* 스프링은 DI(Dependency Injection), DI 컨테이너를 사용하여 OCP, DIP 를 가능하게 지원함
* 클라이언트 코드의 변경 없이 

